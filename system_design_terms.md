Whether you're prepping for system design interviews or building scalable applications, these concepts are *mandatory* to understand — and you’re bound to face them at some level in your career.

Let’s break it down in simple terms:
1. Client-Server Architecture – Like a restaurant: client orders, server serves.
2. IP Address – Think of it as the digital home address for your device.
3. DNS (Domain Name System) – Translates domain names (like google.com) into IP addresses.
4. Proxy vs Reverse Proxy – One hides the client, the other protects the server.
5. Latency – Time taken for a request to travel and return.
6. HTTP/HTTPS – The language your browser speaks with the web.
7. API – Bridge for apps to communicate.
8. REST API – The classic style for API calls (GET, POST, etc.).
9. GraphQL – Ask for just the data you need.
10. Database – Your app’s long-term memory. -- DB
11. SQL vs NoSQL – Tables & schema vs flexible JSON-style storage. -- DB
12. Vertical Scaling – Powering up a server (like upgrading RAM).
13. Horizontal Scaling – Adding more servers to share the load.
14. Load Balancer – Distributes requests smartly.
15. Indexing – Speeds up data retrieval in databases. -- DB
16. Replication – Making backups for high availability. -- DB
17. Sharding – Splitting large data across servers for performance. -- DB
18. Vertical Partitioning – Separating columns to optimize queries. -- DB
19. Caching – Keeping frequently used data close (and fast).
20. Denormalization – Storing redundant data for faster access. -- DB
21. CAP Theorem – You can’t have consistency, availability & partition tolerance all at once. -- DB
22. Blob Storage – For large files like images & videos. -- DB
23. CDN (Content Delivery Network) – Serves content from a server near the user.
24. WebSockets – For real-time communication (e.g., chat apps).
25. Webhooks – Auto-triggered actions on events (like sending a welcome email).
26. Microservices – Breaking apps into manageable, independent services.
27. Message Queue – Processing tasks one at a time to avoid overload.
28. Rate Limiting – Prevents abuse by limiting how often users can hit your APIs.
29. API Gateway – A single entry point for your APIs (handles routing, auth, etc.).
30. Idempotency – Repeating the same request gives the same result — crucial for payments.
31. normalization vs denormalization -- DB
33. batch and stream processing -- DB
34. strong vs eventualy consistent -- DB
35. 𝐐𝐮𝐞𝐫𝐲 𝐎𝐩𝐭𝐢𝐦𝐢𝐳𝐚𝐭𝐢𝐨𝐧 -- DB
36. 𝐂𝐨𝐧𝐧𝐞𝐜𝐭𝐢𝐨𝐧 𝐏𝐨𝐨𝐥𝐢𝐧𝐠 -- DB
37.  𝐌𝐚𝐭𝐞𝐫𝐢𝐚𝐥𝐢𝐳𝐞𝐝 𝐕𝐢𝐞𝐰𝐬-- DB
